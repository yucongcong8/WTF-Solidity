# WTF Solidity 46-57讲 掌握程度检验题 - 标准答案

## 第一部分：代理合约与升级（46-49讲）

### 题目1：代理合约原理

**正确答案：B**

**解析**：
- `delegatecall`在被调合约的上下文中执行，但存储操作发生在**调用者（Proxy）的存储空间**
- 如果状态变量布局不同，`implementation`中的第一个变量会覆盖Proxy中的第一个变量
- 例如：Proxy的`words`=槽位0，Implementation的`admin`=槽位0，会导致管理员地址被重写

**示例危害**：
```solidity
// Proxy
address public implementation;  // slot 0
address public admin;           // slot 1
string public words;            // slot 2

// Implementation（错误顺序）
address public implementation;  // slot 0
string public words;            // slot 1 (不同！会覆盖admin)
address public admin;           // slot 2
```

### 题目2：fallback与delegatecall

**正确答案：D**

**解析**：
1. **返回值丢失**（主要问题）：
   - fallback不会自动返回delegatecall的结果
   - 调用者会收到空返回值
   - 需要使用汇编指令手动返回

2. **缺少成功检查**（次要问题）：
   - 若delegatecall失败，应该revert
   - 虽然有些情况下失败也作为return返回

**正确实现**：
```solidity
fallback() external payable {
    address _impl = implementation;
    assembly {
        calldatacopy(0, 0, calldatasize())
        let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)
        returndatacopy(0, 0, returndatasize())
        switch result
        case 0 { revert(0, returndatasize()) }
        default { return(0, returndatasize()) }
    }
}
```

### 题目3：选择器冲突

**正确答案：D**

**解析**：
- 因为Proxy和Implementation是**两个不同的合约**，同一个选择器在两个合约中可以正常编译
- 但通过代理调用时，Proxy的fallback会将所有调用转发给Implementation
- 如果Admin意图调用升级，选择器碰巧与Implementation中某函数相同，则会执行那个函数而非升级
- 反过来，如果User试图调用foo，但选择器与upgrade相同，Proxy的fallback会访问实现合约... 不对，Transparent Proxy会阻止Admin调用fallback

**透明代理的解决**：
- Admin→只能调upgrade()
- User→只能调实现合约函数（无法调upgrade）
- 分离权限避免冲突

### 题目4：UUPS vs 透明代理

**关键原因**：编译时检查

**解析**：
1. **UUPS优势**：
   - 升级函数在Implementation中
   - 如果Implementation中的某个函数与upgrade()选择器冲突
   - 编译器会报错！因为同一个合约不能有相同选择器的函数
   - 问题在开发阶段就被发现

2. **透明代理的问题**：
   - upgrade()在Proxy中，实现函数在Implementation中
   - 即使冲突也能编译成功
   - 必须运行时+代码审计才能发现

**例子**：
```solidity
// UUPS - 编译时报错❌
contract UUPS1 {
    function upgrade(address newImpl) external { }      // 选择器0xabc123
    function foo(uint x) external { }                  // 选择器碰巧也是0xabc123
    // 编译器报错：同一合约中选择器冲突！
}

// 透明代理 - 编译正常✅但运行时有隐患
contract TransparentProxy {
    function upgrade(address newImpl) external { }      // 选择器0xabc123
}
contract Implementation {
    function foo(uint x) external { }                  // 选择器碰巧也是0xabc123
    // 编译通过！但Admin关键操作会出错
}
```

### 题目5：delegatecall的执行上下文

**答案**：
1. `proxy.x = 10`
2. `impl.x = 100`

**详细解析**：

delegatecall的关键特性：
- **执行上下文** = Implementation的代码
- **存储空间** = Proxy的存储
- **msg.sender保持不变**

**执行流程**：
```solidity
// 虽然setValues是Implementation的函数
// 但运行在Proxy的存储空间中

// Implementation.setValues中的代码等价于在Proxy中执行：
Proxy.x = 10;  // slot 0 修改为10
Proxy.y = 20;  // slot 1 修改为20

// Implementation本身的存储完全不改变
impl.x 仍然 = 100
impl.y 仍然 = 200
```

## 第二部分：多签与权限（50讲）

### 题目6：多签钱包的Nonce机制

**作用**：防签名重放攻击

**具体威胁场景**：
```
假设有一笔已执行的交易：
To: 0x123地址
Value: 1 ETH
Data: transfer(recipient, 1000 USDT)
Nonce: 5
签名: 0xabc...

如果没有nonce检查：
1. 某个知道这笔交易的人截获签名
2. 可以在任何时间反复提交这笔交易
3. 每次都能提取1000 USDT（直到钱包资金耗尽）
```

**多签钱包的nonce保护**：
```solidity
// 执行前检查
require(nonce == currentNonce, "Invalid nonce");

// 执行后递增
nonce++;  // 下一笔交易必须用nonce=6，旧签名失效
```

### 题目7：多签验证流程

**步骤1：构造交易哈希**
- 作用：对要执行的交易进行序列化
- 方法：ABI编码所有参数后计算keccak256
- 包含chainId防止跨链重放

**步骤2：签名恢复**
- 从签名(v, r, s)恢复出签名者地址
- 使用ECDSA算法：`ecrecover(txHash, v, r, s)`
- 多个签名需要按顺序解析

**步骤3：排序检查**
```solidity
// 为什么需要 signer1 < signer2？
// 防止同一个签名被多次使用
// 例如如果允许乱序：
// 签名集合 [A, A, B] 可以通过检查
// 排序要求 [A, B, C] 确保每个签名只计算一次
```

**步骤4：低级调用**
- 使用`call`而非普通函数调用
- 理由：可以调用任意地址上的任意函数
- 支持传value（转账ETH）
- 需要检查success

**步骤5：Nonce递增放在最后**
```solidity
// ✓ 正确顺序
if (success) {
    nonce++;  // 只在执行成功后递增
}
// 这样失败的交易不会浪费nonce
```

## 第三部分：代币标准（51-53讲）

### 题目8：ERC4626计算题

**Alice的LP份额**：
- 首次存入时，使用公式：$\Delta L = \sqrt{\Delta x * \Delta y}$
- 但是金库中仅有一种代币（USDT），所以模型是：$\Delta L = \Delta x$（1:1）
- **Alice获得1000 LP**

**Bob的LP份额**：
- 此时金库状态：totalAssets = 1100 USDT，totalSupply = 1000 LP
- 再存入1000 USDT
- 使用比例公式：$\Delta L = totalSupply * \frac{\Delta assets}{totalAssets}$
- $\Delta L = 1000 * \frac{1000}{1100} = 909.09$ LP
- **Bob获得909.09 LP**

**所占比例**：
- Alice: 1000 / 1909.09 = 52.38%
- Bob: 909.09 / 1909.09 = 47.62%
- 注意：Alice因为先存入，相对收益更高（享受了利息增长）

### 题目9：EIP712签名

**EIP191 (Personal Sign)**：
```javascript
// 用户在钱包看到的
"Sign this message: 0x1234567890abcdef..."
// 只看到16进制哈希，无法验证内容是否符合预期
```

**EIP712 (Typed Data)**：
```javascript
// 用户在钱包看到的
{
  "from": "0x123...",
  "to": "0x456...",
  "amount": "1000 USDT",
  "deadline": "2024-12-31 23:59:00"
}
// 清晰明了，用户能够验证签署内容
```

**技术本质**：
| 特性 | EIP191 | EIP712 |
|-----|--------|--------|
| 签名的消息 | 简单字符串或哈希 | 结构化数据类型 |
| Domain分隔符 | 无 | 有（name, version, chainId, verifyingContract） |
| 防钓鱼性 | 低 | 高 |
| 用户体验 | 差（只看哈希） | 好（看明文结构） |
| 合约验证 | `ecrecover` | 需要验证Domain |

### 题目10：ERC20Permit的优势

**关键优势**：

1. **减少交易数**
   - 传统：2笔tx
   - Permit：1笔tx（permit在链上直接验证）

2. **支持中继**
   ```solidity
   // 用户A持有USDC但没有ETH/gas
   // 1. A在本地签名permit消息
   // 2. A把签名交给有gas的用户B/中继服务
   // 3. B代替A提交交易（B支付gas）
   // 4. A因为有效签名获得授权，完成swap
   
   // 这在ERC20中不可能（只有owner自己调approve）
   ```

3. **用户体验**
   - 减少钱包交互次数
   - 某些脚本可以自动化执行

## 第四部分：跨链与聚合（54-55讲）

### 题目11：跨链桥的三种机制

| 机制 | 源链操作 | 目标链操作 | 风险等级 | 典型用途 |
|-----|--------|----------|--------|---------|
| **Burn/Mint** | D(销毁) | F(铸造) | A(低) | H(项目方自有跨链桥) |
| **Stake/Mint** | E(锁定) | F(铸造) | C(高) | I(一般跨链桥) |
| **Stake/Unstake** | E(锁定) | G(解锁) | B(中) | J(大额交换) + K(需要两链流动性) |

**详细解析**：

**Burn/Mint**
- 源链：销毁用户的代币
- 目标链：铸造等量新代币
- 优点：总供应量守恒，不需要流动性
- 缺点：需要项目方给桥合约铸造权限
- 风险：低（只要代币合约安全）

**Stake/Mint**（最常用）
- 源链：锁定代币到合约
- 目标链：铸造凭证代币（如wrapped token）
- 优点：无需任何权限，最灵活
- 缺点：如果源链被攻击，凭证变空气
- 风险：**最高**（已造成>20亿美元损失）

**Stake/Unstake**
- 源链：锁定资产
- 目标链：创建对应代币（代表源链资产）
- 用户可随时在目标链兑换回源链资产
- 优点：风险可控，资产对等
- 缺点：需在两条链都维护流动性，成本高
- 应用：稳定币、大额资产

### 题目12：MultiCall的应用

**MultiCall的优势**：

1. **原子性保证**
   ```
   情景1：不用MultiCall（多笔tx）
   - 第1笔：查询balance成功
   - 第2笔：网络延迟，其他人先swap导致当前balance变化
   - 第3笔：最后添加流动性时价格滑点严重
   
   情景2：用MultiCall（1笔tx）
   - 在同一个block内同时进行所有操作
   - balance数据一致，no sandwich attack
   ```

2. **减少gas成本**
   ```solidity
   // 不用MultiCall：每笔tx都要支付base fee
   交易1: 21000 gas (base) + 逻辑 = ~50K gas
   交易2: 21000 gas (base) + 逻辑 = ~100K gas  
   交易3: 21000 gas (base) + 逻辑 = ~150K gas
   总计: ~63K gas（仅base fee就浪费63K）
   
   // 用MultiCall：共享1笔交易的base fee
   交易: 21000 gas (base) + 所有逻辑 = ~250K gas
   节省: ~63K gas / tx的base fee
   ```

3. **逻辑关联**
   ```solidity
   // 多笔tx无法表达"如果balance>0就approve"
   
   // MultiCall可以：
   Call[] calls = new Call[](3);
   calls[0] = {target: token0, callData: balanceOf(user)};
   calls[1] = {target: token1, callData: approve(dex, amount)};
   calls[2] = {target: dex, callData: addLiquidity(...)};
   
   multicall(calls);  // 一次性执行
   ```

## 第五部分：DeFi核心（56-57讲）

### 题目13：AMM常数乘积公式

**1. 用户获得的Token B数量**

使用常数乘积公式：$k = x * y = constant$

交易前：$x_1 = 1000, y_1 = 10000$
交易后：$x_2 = 1100, y_2 = ?$

$$k = x_1 * y_1 = x_2 * y_2$$
$$10,000,000 = 1100 * y_2$$
$$y_2 = \frac{10,000,000}{1100} = 9090.91$$

用户获得：$\Delta y = 10000 - 9090.91 = 909.09$ Token B

**2. Token A价格变化**

价格 = 另一种代币 / 这种代币

**交易前**：
$$P_A = \frac{Token B数}{Token A数} = \frac{10000}{1000} = 10 \, B/A$$

**交易后**：
$$P_A = \frac{9090.91}{1100} = 8.264 \, B/A$$

Token A价格**下降**（用户供给增加，价格压低）

**3. Token B价格变化**

**交易前**：
$$P_B = \frac{Token A数}{Token B数} = \frac{1000}{10000} = 0.1 \, A/B$$

**交易后**：
$$P_B = \frac{1100}{9090.91} = 0.121 \, A/B$$

Token B价格**上升**（供给减少，价格升高）

### 题目14：流动性提供者收益

**1. Alice的LP份额**

首次添加流动性时：
$$\Delta L = \sqrt{\Delta x * \Delta y} = \sqrt{100 * 1000} = \sqrt{100,000} = 316.23$$

Alice获得 **316.23 LP份额**

**2. 手续费产生过程**

**交易1（Bob）**：
- 输入：150个Token A
- 手续费：150 * 0.3% = 0.45个Token A
- 实际交易：149.55个Token A
- 交易后池子：100 + 149.55 = 249.55 A / 1000 - 156 = 844 B

**3. LP份额占比**

Alice是第一个LP，提供了全部初始流动性：
- Alice的LP：316.23
- 池子total供应：316.23
- **占比：100%**

### 题目15：闪电贷的原子性

**1. 攻击代码失败原因**
```solidity
❌ WETH.transfer(msg.sender, amount0);
// 错误点：
// - 转账对象应该是Pair合约，不是msg.sender
// - amount0是WETH数量，应该转回给Pair
```

**2. 正确归还闪电贷**

```solidity
function uniswapV2Call(
    address sender,        // sender = Uniswap Pair地址！
    uint256 amount0,       // 借出的Token0数量
    uint256 amount1,       // 借出的Token1数量
    bytes calldata data
) external {
    // 步骤1：验证调用者是真实的Pair合约
    require(msg.sender == pair, "Unauthorized");
    
    // 步骤2：执行套利/清算逻辑
    // ...
    
    // 步骤3：计算手续费（Uniswap V2是0.3%）
    uint256 fee0 = (amount0 * 3) / 1000;
    uint256 amountToRepay0 = amount0 + fee0;
    
    // 步骤4：归还
    WETH.transfer(msg.sender, amountToRepay0);
    USDC.transfer(msg.sender, amount1);
}
```

**3. 不归还的后果**

```solidity
// Uniswap V2的验证（Pair.swap()末尾）
require(
    balance0Adjusted.mul(balance1Adjusted) >= 
    uint(_reserve0).mul(_reserve1).mul(1000**2),
    'UniswapV2: K'
);

// 解析：
// 如果不归还或归还不足：
// balance0Adjusted < reserve0 * 1.0003
// balance1Adjusted < reserve1 * 1.0003
// K值检查失败 → revert → 整个交易回滚
// 看起来没借钱成功 → 闪电贷也没发生
```

**重要概念**：
- 闪电贷的安全性来自交易原子性
- 即使借钱成功，如果不归还就会导致整个交易回滚
- DeFi平台不需要担心坏债
- 套利失败的人也不需要赔钱

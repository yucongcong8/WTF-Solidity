# 31-45讲 学习检验题

## 一、基础概念题（每题10分）

### 1. ERC20 vs ERC721 对比
**问题**：为什么ERC20用`balanceOf()`而ERC721要用`ownerOf()`？这体现了什么本质区别？

**你的答案**：
```


```

---

### 2. 荷兰拍卖价格计算
**问题**：已知拍卖参数如下，计算第5分钟时的NFT价格。

```solidity
AUCTION_START_PRICE = 1 ether      // 起始价
AUCTION_END_PRICE = 0.1 ether      // 结束价
AUCTION_TIME = 10 minutes           // 拍卖总时长
AUCTION_DROP_INTERVAL = 1 minute    // 每分钟降一次
```

**计算过程**：
```


```

**答案**：

---

### 3. 默克尔树证明
**问题**：如果你知道某个叶子的merkle proof为`[hash1, hash2]`，能否直接执行交易？为什么？

**答案**：
```


```

---

### 4. ECDSA签名流程
**问题**：数字签名中为什么要加`"\x19Ethereum Signed Message:\n32"`前缀？

**答案**：
```


```

---

## 二、代码分析题（每题15分）

### 5. 空投合约的漏洞检查
```solidity
function multiTransferToken(
    address _token,
    address[] calldata _addresses,
    uint256[] calldata _amounts
) external {
    require(_addresses.length == _amounts.length, "Length not match");
    IERC20 token = IERC20(_token);
    uint _amountSum = getSum(_amounts);
    require(token.allowance(msg.sender, address(this)) >= _amountSum, "Need Approve");
    
    for (uint8 i; i < _addresses.length; i++) {  // ← 有问题！
        token.transferFrom(msg.sender, _addresses[i], _amounts[i]);
    }
}
```

**问题**：这段代码有什么潜在问题？为什么不能用`uint8`？

**答案**：
```


```

---

### 6. NFT交易所的Order设计
```solidity
struct Order {
    address owner;
    uint256 price;
}
mapping(address => mapping(uint256 => Order)) public nftList;
```

**问题**：为什么要用嵌套mapping而不是简单数组？两种方案的优缺点？

**答案**：
```


```

---

### 7. 线性释放的时间计算
```solidity
function vestedAmount(address token, uint256 timestamp) public view returns (uint256) {
    if (timestamp < start) {
        return 0;
    } else if (timestamp >= start + duration) {
        return IERC20(token).balanceOf(address(this)) + erc20Released[token];
    } else {
        // 关键计算在这里
        return (initialBalance * (timestamp - start)) / duration;
    }
}
```

**问题**：假设初始余额100代币，归属期1年，现在是归属期第6个月，应该释放多少？

**答案**：
```


```

---

## 三、场景应用题（每题20分）

### 8. 设计一个混合空投方案
**场景**：你要给5000个用户空投WTF代币，但不同用户等级不同：
- VIP用户(100人)：每人500万WTF
- 普通用户(4900人)：每人100万WTF

**要求**：
- 单笔交易完成
- 节省gas费用
- 描述合约核心逻辑

```solidity
// 你的实现方案
contract TieredAirdrop {
    // 代码实现
    
}
```

**设计说明**：
```


```

---

### 9. ERC1155游戏物品系统
**场景**：设计一个游戏角色装备系统，需要支持：
- 武器(唯一):  id=1, 每人最多1件
- 防甲(唯一):  id=2, 每人最多1件  
- 药水(可重复): id=3, 每人无限量，可叠加

**要求**：用ERC1155实现，说明每种物品的铸造和转账限制

```solidity
// 伪代码或说明
interface 限制条件 {
    // 写出你的控制逻辑
}
```

---

### 10. 时间锁+分账的组合应用
**场景**：DAOTreasury金库使用时间锁进行安全管理，同时要求：
- 提款需要2天锁定期（安全）
- 提款后按3个共同创始人分账（A:40%, B:35%, C:25%）

**问题**：
1. 时间锁和分账合约之间如何交互？
2. 提款流程是怎样的？
3. 如果其中一个创始人地址失效，怎么办？

**答案**：
```


```

---

## 四、代码补全题（每题15分）

### 11. 完成一个Merkle白名单验证合约

```solidity
pragma solidity ^0.8.21;

import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

contract MerkleWhitelistNFT is ERC721 {
    bytes32 public merkleRoot;
    mapping(address => bool) public claimed;
    uint256 private tokenId = 0;
    
    constructor(bytes32 _merkleRoot) ERC721("WL NFT", "WLNFT") {
        merkleRoot = _merkleRoot;
    }
    
    // ❌ 需要你补全这个函数
    function claim(bytes32[] calldata proof) external {
        // 1. 验证调用者在白名单中
        // 2. 验证调用者没有领过
        // 3. 铸造NFT给调用者
        // 提示：使用 MerkleProof.verify()
    }
}
```

**你的实现**：
```solidity
function claim(bytes32[] calldata proof) external {
    // 在这里补全


}
```

---

### 12. 完成WETH的提款函数

```solidity
contract WETH is ERC20 {
    event Withdrawal(address indexed src, uint wad);
    
    // ❌ 需要你补全这个函数
    function withdraw(uint amount) public {
        // 1. 检查调用者余额足够
        // 2. 销毁调用者的WETH
        // 3. 发送等额ETH给调用者
        // 4. 释放事件
    }
}
```

**你的实现**：
```solidity
function withdraw(uint amount) public {
    // 在这里补全


}
```

---

## 五、对比分析题（每题10分）

### 13. ERC721 vs ERC1155 在游戏中的应用

| 维度 | ERC721 | ERC1155 |
|------|--------|---------|
| 装备数量 | ? | ? |
| Gas效率 | ? | ? |
| 单次转账多项 | ? | ? |
| 适合场景 | ? | ? |

**填空**：完成上面的对比表

---

### 14. 链上随机 vs Chainlink VRF

| 对比项 | 链上伪随机 | Chainlink VRF |
|--------|----------|---------------|
| 安全性 | ? | ? |
| Gas成本 | ? | ? |
| 执行速度 | ? | ? |
| 被攻击风险 | ? | ? |

**填空**：完成上面的对比表

---

## 六、综合设计题（30分）

### 15. 设计一个完整的NFT项目生命周期

**需求**：
1. **阶段1**：项目方发起荷兰拍卖发售1000个NFT
2. **阶段2**：交易完成后，项目方收入通过分账合约分给运营团队
3. **阶段3**：用户在NFT交易所交易  
4. **阶段4**：项目方提取分账时受时间锁保护

**要求**：
- 画出合约间的交互流程图（文字版）
- 列出涉及的主要合约和函数
- 说明各阶段的时间参数

```
你的设计方案：

1. 合约清单：
   - 合约A: ___
   - 合约B: ___
   - ...

2. 交互流程：
   主线程：用户 → ____ → ____ → ____
   支线程：项目方 → ____ → ____ → ____

3. 时间参数：
   - 荷兰拍卖时长: ___
   - 时间锁延迟: ___
   - ...

```

---

## 评分标准

| 题型 | 题数 | 单题分 | 总分 |
|------|------|--------|------|
| 概念题 | 4 | 10 | 40 |
| 代码分析 | 3 | 15 | 45 |
| 场景应用 | 3 | 20 | 60 |
| 代码补全 | 2 | 15 | 30 |
| 对比分析 | 2 | 10 | 20 |
| 综合设计 | 1 | 30 | 30 |
| **总计** | **15** | — | **225** |

### 等级划分
- **90分以上**（≥202.5分）：🌟🌟🌟 精通，可独立开发应用合约
- **80-89分**（178.5-202.5分）：🌟🌟 良好，理解核心概念，可完成中等任务
- **70-79分**（157.5-178.5分）：🌟 及格，掌握基础，需加强实践
- **60-69分**（135-157.5分）：⚠️ 需要复习某些重点章节
- **<60分**（<135分）：❌ 建议重新学习基础内容

---

## 提交方式

完成检验题后，可以：
1. **逐题给我答案**（推荐交互检验）
2. **指定几题深入讨论**（重点掌握情况）
3. **遇到不会的题**（我详细讲解）

**开始吧！先从第1题开始？** 😊

# 1-30讲 详细测试题

---
title: 1-30讲 详细测试题
tags:
  - solidity
  - review
  - detailed
  - questions
  - wtfacademy
---

## 一、基础概念题（每题10分）

### 1. 数据存储位置详解
**问题**：请详细解释 `storage`、`memory` 和 `calldata` 的区别，包括：
- 存储位置
- 生命周期
- 访问成本
- 适用场景
- 赋值行为

**你的答案**：
```


```

---

### 2. 函数可见性与修饰符
**问题**：
1. Solidity 中有哪四种函数可见性？它们的访问范围分别是什么？
2. 请解释 `pure`、`view` 和 `payable` 修饰符的作用和限制。

**你的答案**：
```


```

---

### 3. 修饰器执行机制
**问题**：
1. 当一个函数有多个修饰器时，执行顺序是怎样的？请举例说明。
2. 修饰器中 `_;` 的作用是什么？如果一个修饰器没有 `_;` 会发生什么？

**你的答案**：
```


```

---

### 4. ETH 转账机制
**问题**：
1. Solidity 中有哪三种发送 ETH 的方法？它们的语法和区别是什么？
2. 为什么 `call()` 是当前推荐的发送 ETH 方法？
3. 请写出使用 `call()` 安全发送 ETH 的代码示例。

**你的答案**：
```


```

---

## 二、代码分析题（每题15分）

### 5. 插入排序的 Bug 分析
```solidity
function insertionSortWrong(uint[] memory a) public pure returns(uint[] memory) {
    for (uint i = 1; i < a.length; i++) {
        uint temp = a[i];
        uint j = i - 1;
        while ((j >= 0) && (temp < a[j])) {
            a[j + 1] = a[j];
            j--;
        }
        a[j + 1] = temp;
    }
    return(a);
}
```

**问题**：
1. 这段代码存在什么 Bug？请详细分析原因。
2. 如何修复这个 Bug？请写出正确的代码。
3. 为什么在 Solidity 中实现排序算法需要特别注意这些问题？

**你的答案**：
```


```

---

### 6. Delegatecall 安全分析
```solidity
contract Proxy {
    address public implementation;
    
    function upgrade(address _newImpl) public {
        implementation = _newImpl;
    }
    
    fallback() external payable {
        (bool success, ) = implementation.delegatecall(msg.data);
        require(success, "Delegatecall failed");
    }
}
```

**问题**：
1. 这段代码存在什么安全风险？请详细分析。
2. 如何防范这些安全风险？请写出改进后的代码。
3. Delegatecall 的工作原理是什么？它与 Call 的区别是什么？

**你的答案**：
```


```

---

### 7. ABI 编码与解码
```solidity
function encodeTest() public pure returns (
    bytes memory, 
    bytes memory, 
    bytes4
) {
    bytes memory encoded = abi.encode(123, "hello", address(0x123));
    bytes memory encodedPacked = abi.encodePacked(123, "hello", address(0x123));
    bytes4 selector = bytes4(keccak256("transfer(address,uint256)"));
    return (encoded, encodedPacked, selector);
}
```

**问题**：
1. `abi.encode` 和 `abi.encodePacked` 的区别是什么？请分析它们的编码结果。
2. 函数选择器的计算方法是什么？它在合约调用中的作用是什么？
3. 请写出如何使用函数选择器和 `call` 方法调用 `transfer` 函数。

**你的答案**：
```


```

---

## 三、场景应用题（每题20分）

### 8. 权限控制与管理
**场景**：设计一个具有多级权限的合约，包括：
- 管理员（最高权限）
- 操作员（可执行特定操作）
- 查看者（只能查看信息）

**要求**：
1. 实现权限的分配和转移
2. 实现权限检查修饰器
3. 包含不同权限级别的函数
4. 防止权限提升攻击

**你的实现**：
```solidity
contract MultiAccessControl {
    // 在这里实现
}
```

**设计说明**：
```


```

---

### 9. 安全的 ETH 处理合约
**场景**：设计一个可以安全接收和发送 ETH 的合约，用于管理团队资金。

**要求**：
1. 实现 `receive()` 和 `fallback()` 函数
2. 实现安全的 ETH 发送功能（使用 `call()`）
3. 实现资金管理功能（如分账、提款限制等）
4. 添加事件记录所有 ETH 流动

**你的实现**：
```solidity
contract ETHManager {
    // 在这里实现
}
```

**设计说明**：
```


```

---

### 10. 数据验证与处理
**场景**：设计一个用户数据注册合约，需要验证和处理用户提交的数据。

**要求**：
1. 实现用户数据的存储结构
2. 实现数据验证功能
3. 实现数据的添加、更新、删除功能
4. 实现数据查询功能

**你的实现**：
```solidity
contract UserRegistry {
    // 在这里实现
}
```

**设计说明**：
```


```

---

## 四、代码补全题（每题15分）

### 11. 完成 onlyOwner 修饰器和管理员转移功能
```solidity
contract Ownable {
    address private _owner;
    
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    
    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }
    
    // ❌ 需要补全 onlyOwner 修饰器
    modifier onlyOwner() {
        // 1. 检查调用者是否是管理员
        // 2. 执行后续代码
    }
    
    // ❌ 需要补全管理员转移函数
    function transferOwnership(address newOwner) public {
        // 1. 检查新管理员地址是否有效
        // 2. 转移所有权
        // 3. 触发事件
    }
    
    function owner() public view returns (address) {
        return _owner;
    }
}
```

**你的实现**：
```solidity
// 补全 onlyOwner 修饰器
modifier onlyOwner() {
    // 在这里补全

}

// 补全管理员转移函数
function transferOwnership(address newOwner) public {
    // 在这里补全

}
```

---

### 12. 完成 Try-Catch 异常处理
```solidity
contract ErrorHandler {
    event CallSuccess(bytes data);
    event CallFailure(string reason);
    
    // ❌ 需要补全 tryCatchExample 函数
    function tryCatchExample(address target, bytes memory data) public {
        // 1. 使用 try-catch 调用目标合约
        // 2. 捕获不同类型的异常
        // 3. 触发相应的事件
    }
}
```

**你的实现**：
```solidity
function tryCatchExample(address target, bytes memory data) public {
    // 在这里补全

}
```

---

## 五、对比分析题（每题10分）

### 13. require vs assert vs revert 详细对比
| 维度 | require | assert | revert |
|------|---------|--------|--------|
| 底层实现 | ? | ? | ? |
| Gas 消耗 | ? | ? | ? |
| 错误处理 | ? | ? | ? |
| 适用场景 | ? | ? | ? |
| 最佳实践 | ? | ? | ? |

**填空**：完成上面的对比表，并详细说明各自的使用场景。

**你的答案**：
```


```

---

### 14. storage vs memory vs calldata 详细对比
| 维度 | storage | memory | calldata |
|------|---------|--------|----------|
| 存储位置 | ? | ? | ? |
| 生命周期 | ? | ? | ? |
| 访问成本 | ? | ? | ? |
| 可修改性 | ? | ? | ? |
| 适用场景 | ? | ? | ? |

**填空**：完成上面的对比表，并详细说明各自的使用场景。

**你的答案**：
```


```

---

## 六、综合设计题（30分）

### 15. 设计一个完整的可升级代币合约系统
**需求**：
1. **核心功能**：实现一个 ERC20 代币合约，支持转账、授权等基本功能
2. **权限控制**：实现管理员权限，只有管理员可以升级合约
3. **可升级性**：使用代理模式实现合约升级
4. **安全保障**：实现重入锁、溢出保护等安全措施
5. **事件记录**：记录所有重要操作的事件

**要求**：
1. 画出合约架构图（文字版），包括代理合约、实现合约和权限管理
2. 列出主要合约和函数，说明它们的作用
3. 详细说明升级流程和安全措施
4. 分析系统的优缺点和潜在风险

**你的设计方案**：
```
1. 合约架构：
   - 代理合约：负责存储数据和转发调用
   - 实现合约：包含代币业务逻辑
   - 权限管理合约：控制升级权限

2. 主要合约和函数：
   - 代理合约：fallback()、upgradeTo()
   - 实现合约：transfer()、approve()、transferFrom()、mint()、burn()
   - 权限管理合约：onlyAdmin()、transferAdmin()

3. 升级流程：
   - 部署新的实现合约
   - 管理员调用代理合约的 upgradeTo() 函数
   - 代理合约更新实现地址
   - 新的调用将转发到新的实现合约

4. 安全措施：
   - 重入锁：防止重入攻击
   - 溢出保护：使用 SafeMath 或 Solidity 0.8+ 的内置检查
   - 权限控制：确保只有管理员可以升级
   - 事件记录：记录所有重要操作

5. 优缺点分析：
   - 优点：可升级性、灵活性、安全保障
   - 缺点：复杂度增加、潜在的升级风险
   - 风险：代理合约漏洞、升级失败导致资金锁定

```

---

## 评分标准

| 题型 | 题数 | 单题分 | 总分 |
|------|------|--------|------|
| 概念题 | 4 | 10 | 40 |
| 代码分析 | 3 | 15 | 45 |
| 场景应用 | 3 | 20 | 60 |
| 代码补全 | 2 | 15 | 30 |
| 对比分析 | 2 | 10 | 20 |
| 综合设计 | 1 | 30 | 30 |
| **总计** | **15** | — | **225** |

### 等级划分
- **90分以上**（≥202.5分）：🌟🌟🌟 精通，可独立开发复杂合约
- **80-89分**（178.5-202.5分）：🌟🌟 良好，理解核心概念，可完成中等任务
- **70-79分**（157.5-178.5分）：🌟 及格，掌握基础，需加强实践
- **60-69分**（135-157.5分）：⚠️ 需要复习某些重点章节
- **<60分**（<135分）：❌ 建议重新学习基础内容

---

## 测试重点

本测试题重点考察以下能力：

1. **基础理论**：对 Solidity 核心概念的理解
2. **代码分析**：分析和解决代码问题的能力
3. **实践应用**：设计和实现实际合约的能力
4. **安全意识**：识别和防范安全风险的能力
5. **综合设计**：设计完整系统的能力

通过完成这些测试题，你可以全面检验自己对 1-30 讲内容的掌握程度，找出不足之处并加以改进。

---

## 提交方式

完成测试题后，可以：
1. **逐题给我答案**（推荐交互检验）
2. **指定几题深入讨论**（重点掌握情况）
3. **遇到不会的题**（我详细讲解）

**开始吧！先从第1题开始？** 😊